{"version":3,"sources":["app/RpcCommon.ts"],"names":[],"mappings":";;;;;;;;;;;AAAA,mCAAsC;AAGtC,+DAAkG;AA+FlG,mBAAmB;AAGnB,IAAsB,aAAa,GAAnC;IAeC;QACC,IAAI,CAAC,QAAQ,GAAG,IAAI,qBAAY,EAAE,CAAC;QACnC,IAAI,CAAC,OAAO,GAAG,KAAK,CAAC;IACtB,CAAC;IAEM,OAAO;QACb,IAAI,CAAC,QAAQ,CAAC,kBAAkB,EAAE,CAAC;QACnC,IAAI,CAAC,QAAQ,GAAG,IAAI,CAAC;QACrB,MAAM,CAAC,OAAO,CAAC,OAAO,EAAE,CAAC;IAC1B,CAAC;IAED;;OAEG;IACI,OAAO,CAAC,OAAsB;QACpC,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;IACpC,CAAC;IAGS,SAAS,CAAC,GAAG;QACtB,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;IAClC,CAAC;CACD,CAAA;AArCqB,aAAa;IADlC,iCAAU,EAAE;;GACS,aAAa,CAqClC;AArCqB,sCAAa;AAwCnC,IAAsB,cAAc,GAApC;IAUC,YAAsB,aAAmC;QAAnC,kBAAa,GAAb,aAAa,CAAsB;QACxD,4BAAK,CAAC,gBAAgB,CAAC,eAAe,EAAE,aAAa,CAAC,CAAC;QACvD,IAAI,CAAC,QAAQ,GAAG,IAAI,qBAAY,EAAE,CAAC;IACpC,CAAC;IAGD;;OAEG;IACI,OAAO,CAAC,OAAsB;QACpC,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,OAAO,EAAE,OAAO,CAAC,CAAC;IACpC,CAAC;IAGS,SAAS,CAAC,GAAG;QACtB,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,OAAO,EAAE,GAAG,CAAC,CAAC;IAClC,CAAC;IAES,iBAAiB,CAAC,MAAc,EAAE,KAAsB,EAAE,UAA6B;QAChG,yCAAyC;QACzC,IAAI,QAAQ,GAAG,IAAI,CAAC,aAAa,CAAC,OAAO,CAAM,KAAK,CAAC,CAAC;QACtD,4BAAK,CAAC,eAAe,CAAC,QAAQ,EAAE,6BAA6B,KAAK,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;QAElF,IAAI,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC,CAAC;QAEhC,0EAA0E;QAC1E,EAAE,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;YACf,QAAQ,GAAG,CAAC,UAAU,GAAG,UAAU,CAAC,QAAQ,EAAE,MAAM,CAAC,GAAG,IAAI,CAAC,CAAC;QAC/D,CAAC;QAED,4BAAK,CAAC,cAAc,CAAC,QAAQ,EAAE,gDAAgD,CAAC,CAAC;QAEjF,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;IAChC,CAAC;IAES,cAAc,CAAC,SAAS,EAAE,IAAI,EAAE,OAAe;QACxD,MAAM,CAAC;YACN,SAAS;YACT,IAAI,EAAE,IAAI,CAAC,IAAI;YACf,EAAE,EAAE,OAAO;YACX,IAAI;SACJ,CAAC;IACH,CAAC;CACD,CAAA;AArDqB,cAAc;IADnC,iCAAU,EAAE;;GACS,cAAc,CAqDnC;AArDqB,wCAAc","file":"RpcCommon.js","sourcesContent":["import { EventEmitter } from 'events';\r\n\r\nimport * as express from 'express-serve-static-core';\r\nimport { injectable, IDependencyContainer, Guard, CriticalException } from 'back-lib-common-util';\r\n\r\n// Interface - Service contract\r\n\r\nexport interface IRpcRequest extends Json {\r\n\tfrom: string;\r\n\tto: string;\r\n\tpayload: any;\r\n}\r\n\r\nexport interface IRpcResponse extends Json {\r\n\tisSuccess: boolean;\r\n\tfrom: string;\r\n\tto: string;\r\n\tdata: any;\r\n}\r\n\r\n// Interface - RPC caller and handler\r\n\r\nexport interface IRpcCaller {\r\n\t/**\r\n\t * A name used in \"from\" and \"to\" request property.\r\n\t */\r\n\tname: string;\r\n\r\n\t/**\r\n\t * Number of seconds to wait for response before cancelling the request.\r\n\t */\r\n\ttimeout: number;\r\n\r\n\t/**\r\n\t * Sets up this RPC caller with specified `param`. Each implementation class requires\r\n\t * different kinds of `param`.\r\n\t */\r\n\tinit(params?: any): any;\r\n\r\n\t/**\r\n\t * Clear resources.\r\n\t */\r\n\tdispose(): Promise<void>;\r\n\r\n\t/**\r\n\t * Sends a request to `moduleName` to execute `action` with `params`.\r\n\t * @param moduleName The module to send request.\r\n\t * @param action The function name to call on `moduleName`.\r\n\t * @param params Parameters to pass to function `action`.\r\n\t */\r\n\tcall(moduleName: string, action: string, params?: any): Promise<IRpcResponse>;\r\n\r\n\t/**\r\n\t * Registers a listener to handle errors.\r\n\t */\r\n\tonError(handler: (err) => void): void;\r\n}\r\n\r\n\r\nexport type RpcControllerFunction = (requestPayload: any, resolve: PromiseResolveFn, reject: PromiseRejectFn, rawRequest: IRpcRequest) => any;\r\nexport type RpcActionFactory = (controller, action: string) => RpcControllerFunction;\r\n\r\nexport interface IRpcHandler {\r\n\t/**\r\n\t * A name used in \"from\" and \"to\" request property.\r\n\t */\r\n\tname: string;\r\n\t\r\n\t/**\r\n\t * Sets up this RPC handler with specified `param`. Each implementation class requires\r\n\t * different kinds of `param`.\r\n\t */\r\n\tinit(params?: any): any;\r\n\r\n\t/**\r\n\t * Waits for incoming request, resolves an instance with `dependencyIdentifier`,\r\n\t * calls instance's `action` method. If `customAction` is specified, \r\n\t * calls instance's `customAction` instead.\r\n\t */\r\n\thandle(action: string | string[], dependencyIdentifier: string | symbol, actionFactory?: RpcActionFactory): any;\r\n\r\n\t/**\r\n\t * Registers a listener to handle errors.\r\n\t */\r\n\tonError(handler: (err) => void): void;\r\n\r\n\t/**\r\n\t * Starts listening to requests.\r\n\t */\r\n\tstart(): Promise<void>;\r\n\r\n\t/**\r\n\t * Stops handling requests and removes registered actions.\r\n\t */\r\n\tdispose(): Promise<void>;\r\n}\r\n\r\n\r\n// RPC Base classes\r\n\r\n@injectable()\r\nexport abstract class RpcCallerBase {\r\n\r\n\t/**\r\n\t * @see IRpcCaller.name\r\n\t */\r\n\tpublic name: string;\r\n\r\n\t/**\r\n\t * @see IRpcCaller.timeout\r\n\t */\r\n\tpublic timeout: number;\r\n\r\n\tprotected _emitter: EventEmitter;\r\n\r\n\r\n\tconstructor() {\r\n\t\tthis._emitter = new EventEmitter();\r\n\t\tthis.timeout = 30000;\r\n\t}\r\n\t\r\n\tpublic dispose(): Promise<void> {\r\n\t\tthis._emitter.removeAllListeners();\r\n\t\tthis._emitter = null;\r\n\t\treturn Promise.resolve();\r\n\t}\r\n\r\n\t/**\r\n\t * @see IRpcCaller.onError\r\n\t */\r\n\tpublic onError(handler: (err) => void): void {\r\n\t\tthis._emitter.on('error', handler);\r\n\t}\r\n\r\n\r\n\tprotected emitError(err): void {\r\n\t\tthis._emitter.emit('error', err);\r\n\t}\r\n}\r\n\r\n@injectable()\r\nexport abstract class RpcHandlerBase {\r\n\r\n\t/**\r\n\t * @see IRpcHandler.name\r\n\t */\r\n\tpublic name: string;\r\n\r\n\tprotected _emitter: EventEmitter;\r\n\r\n\r\n\tconstructor(protected _depContainer: IDependencyContainer) {\r\n\t\tGuard.assertArgDefined('_depContainer', _depContainer);\r\n\t\tthis._emitter = new EventEmitter();\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * @see IRpcHandler.onError\r\n\t */\r\n\tpublic onError(handler: (err) => void): void {\r\n\t\tthis._emitter.on('error', handler);\r\n\t}\r\n\r\n\r\n\tprotected emitError(err): void {\r\n\t\tthis._emitter.emit('error', err);\r\n\t}\r\n\r\n\tprotected resolveActionFunc(action: string, depId: string | symbol, actFactory?: RpcActionFactory): RpcControllerFunction {\r\n\t\t// Attempt to resolve controller instance\r\n\t\tlet instance = this._depContainer.resolve<any>(depId);\r\n\t\tGuard.assertIsDefined(instance, `Cannot resolve dependency ${depId.toString()}!`);\r\n\r\n\t\tlet actionFn = instance[action];\r\n\t\t\r\n\t\t// If default action is not available, attempt to get action from factory.\r\n\t\tif (!actionFn) {\r\n\t\t\tactionFn = (actFactory ? actFactory(instance, action) : null);\r\n\t\t}\r\n\r\n\t\tGuard.assertIsTruthy(actionFn, 'Specified action does not exist in controller!');\r\n\r\n\t\treturn actionFn.bind(instance);\r\n\t}\r\n\r\n\tprotected createResponse(isSuccess, data, replyTo: string): IRpcResponse {\r\n\t\treturn {\r\n\t\t\tisSuccess,\r\n\t\t\tfrom: this.name,\r\n\t\t\tto: replyTo,\r\n\t\t\tdata\r\n\t\t};\r\n\t}\r\n}\r\n"]}